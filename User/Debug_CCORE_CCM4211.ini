/***********************************************************/
 /* Debug_RAM.ini: Initialization File for Debugging from Internal RAM */
 /******************************************************/
 /* This file is part of the uVision/ARM development tools. */
 /* Copyright (c) 2005-2014 Keil Software. All rights reserved. */
 /* This software may only be used under the terms of a valid, current, */
 /* end user licence from KEIL for a compatible version of KEIL software */
 /*development tools. Nothing else gives you the right to use this software */
 /***************************************************/

FUNC void Setup (void) {
uint32_t app_start_addr;
app_start_addr =&main;	
if((app_start_addr>0x10000000) &&(app_start_addr<0x12000000))
{
 SP = _RDWORD(0x10001000); // 设置栈指针SP，把0x20000000 地址中的内容赋值到SP。
 PC = _RDWORD(0x10001004); // 设置程序指针PC，把0x20000004 地址中的内容赋值到PC。
 XPSR = 0x01000000; // 设置状态寄存器指针xPSR
 _WDWORD(0xE000ED08, 0x10000000); // Setup Vector Table Offset Register
}
else if((app_start_addr>0x14000000) &&(app_start_addr<0x1c000000))
{
 SP = _RDWORD(0x14001000); // 设置栈指针SP，把0x20000000 地址中的内容赋值到SP。
 PC = _RDWORD(0x14001004); // 设置程序指针PC，把0x20000004 地址中的内容赋值到PC。
 XPSR = 0x01000000; // 设置状态寄存器指针xPSR
 _WDWORD(0xE000ED08, 0x14001000); // Setup Vector Table Offset Register
}
else if((app_start_addr>0x1fffffff) &&(app_start_addr<0x20018000))
{
SP = _RDWORD(0x20000000); // 设置栈指针SP，把0x20000000 地址中的内容赋值到SP。
PC = _RDWORD(0x20000004); // 设置程序指针PC，把0x20000004 地址中的内容赋值到PC。
XPSR = 0x01000000; // 设置状态寄存器指针xPSR
_WDWORD(0xE000ED08, 0x20000000); // Setup Vector Table Offset Register	
}
 }

FUNC void Spiflash_WaitStatDone1(void)
{
	unsigned long reg;
	unsigned long retVal;
	do
	{
		reg = _RDWORD(0xC1000028);
	}while((reg & 0x04) == 0x00);

	do
	{
		reg = _RDWORD(0xC1000028);
	}while((reg & 0x01));


	do
	{
		reg = _RDWORD(0xC1000028);
	} while((reg & 0x08)==0);


	retVal = _RDWORD(0xC1000060);

}
FUNC void Spiflash_WaitStatDone2(void)
{
	unsigned long reg;
	unsigned long retVal;
	do
	{
		reg = _RDWORD(0xC1000028);
	}while((reg & 0x04) == 0x00);

	do
	{
		reg = _RDWORD(0xC1000028);
	}while((reg & 0x01));
  
		 
}
FUNC void Eflash_qpi_enter()
{		
	_WDWORD(0xC1000060, 0x38);//rSSI_DR=QPI_ENTER_CMD;	
	Spiflash_WaitStatDone1();	
}	

FUNC void Eflash_set_read_para()
{
	unsigned int temp;

	_WDWORD(0xC1000008, 0x00);// rSSI_SSIENR = 0x00;
	_WDWORD(0xC1000004, 0x00);//rSSI_CTRLR1 = 0x00;   
	_WDWORD(0xC1000000, 0x00800407);//rSSI_CTRLR0 = 0x00800407;	 
	_WDWORD(0xC10000f4, 0x40000202|(6<<11));//rSSI_SPI_CTRLR0 = 0x40000202|(6<<11);
	_WDWORD(0xC1000014, 0x02);//rSSI_BAUDR =  0x10;	
	_WDWORD(0xC100002c, 0x00);//rSSI_IMR = 0x00;		
	_WDWORD(0xC1000018, 0x010000);	//设置发送阈值为1
	_WDWORD(0xC1000008, 0x01);// rSSI_SSIENR = 0x01;

	_WDWORD(0xC1000060, 0xc0);//rSSI_DR=SET_READ_PARA_CMD;
	_WDWORD(0xC1000060, 0x21);//rSSI_DR=0x21; //0x21;
	Spiflash_WaitStatDone2();	
}	

FUNC void SSI1_standard_init()
{
	_WDWORD(0xC1000008, 0x00);//rSSI_SSIENR = 0x00;
	_WDWORD(0xC1000004, 0x00);  //rSSI_CTRLR1 = 0x00;
	_WDWORD(0xC1000000, 0x00000007);	 //rSSI_CTRLR0 = 0x07;
	_WDWORD(0xC1000014, 0x02);//rSSI_BAUDR = 0x8;
	_WDWORD(0xC1000018, 0x00);//rSSI_TXFTLR = 0x00;
	_WDWORD(0xC100001c, 0x00);//rSSI_RXFTLR = 0x00;
	_WDWORD(0xC10000f4, 0x8000);//rSSI_SPI_CTRLR0 = 0x8000;
	_WDWORD(0xC100002c, 0x00);	// rSSI_IMR = 0x00;	
	_WDWORD(0xC1000008, 0x01);//rSSI_SSIENR = 0x01;
}	
FUNC void Xip_enable()
{
	unsigned int temp;

	_WDWORD(0xC1000008, 0x00);//rSSI_SSIENR= 0x00;
	_WDWORD(0xC1000100, 0xeb);//XIP_INCR_INST= 0xeb; 
	_WDWORD(0xC1000104, 0x0c);//XIP_WRAP_INST= 0x0c;
	_WDWORD(0xC10000fc, 0x00);//rSSI_XIP_MODE_BITS=0X0000;
	_WDWORD(0xC1000014, 0x02);//rSSI_BAUDR= 0X08;
	_WDWORD(0xC1000108, 0x28c0946a);//XIP_CTRL= 0x28c0946a;	
	_WDWORD(0xC1000000, 0x0080001f);//rSSI_CTRLR0= 0x0080001f;
	_WDWORD(0xC10000f4, 0x6830021a|(6<<11));//rSSI_SPI_CTRLR0= 0x6830021a|(6<<11);	
	_WDWORD(0xC10000f0,0x00010000);//rSSI_RX_SAMPLE_DELAY	
	_WDWORD(0xC1000008, 0x01);//rSSI_SSIENR= 0x01;
	_Sleep_(3);

	_WDWORD(0x4000103c,  _RDWORD(0x4000103c)|(1<<16)|(1<<20));
	_Sleep_(3);

 
}
FUNC void Xip1_enable()
{
	unsigned int temp;

	_WDWORD(0xC1000008, 0x00);//rSSI_SSIENR= 0x00;
	_WDWORD(0xC1000100, 0xeb);//XIP_INCR_INST= 0xeb; 
	_WDWORD(0xC1000104, 0xeb);//XIP_WRAP_INST= 0x0c;
	_WDWORD(0xC10000fc, 0x00);//rSSI_XIP_MODE_BITS=0X0000;
	_WDWORD(0xC1000014, 0x02);//rSSI_BAUDR= 0X08;
//	_WDWORD(0xC1000014, 0x08);
	_WDWORD(0xC1000108, 0x28c09466);//XIP_CTRL= 0x28c0946a;		
	_WDWORD(0xC1000000, 0x0080001f);//rSSI_CTRLR0= 0x0080001f;	
	_WDWORD(0xC10000f0,0x00000001);//rSSI_RX_SAMPLE_DELAY	
	_WDWORD(0xC1000008, 0x01);//rSSI_SSIENR= 0x01;
	_Sleep_(3);


	_WDWORD(0x4000103c, 0x7711e7f2); //开自动wrap
	_Sleep_(3);
}
FUNC void Xip3_enable()
{
	unsigned int temp;

	_WDWORD(0xC3000008, 0x00);//rSSI_SSIENR= 0x00;
	_WDWORD(0xC3000100, 0xeb);//XIP_INCR_INST= 0xeb; 
	_WDWORD(0xC3000104, 0xeb);//XIP_WRAP_INST= 0x0c;
	_WDWORD(0xC30000fc, 0x00);//rSSI_XIP_MODE_BITS=0X0000;
	_WDWORD(0xC3000014, 0x08);//rSSI_BAUDR= 0X08;
	_WDWORD(0xC3000108, 0x28c09466);//XIP_CTRL= 0x28c0946a;		
	_WDWORD(0xC3000000, 0x0080001f);//rSSI_CTRLR0= 0x0080001f;	
	_WDWORD(0xC30000f0,0x00000001);//rSSI_RX_SAMPLE_DELAY	
	_WDWORD(0xC3000008, 0x01);//rSSI_SSIENR= 0x01;
	_Sleep_(3);


	_WDWORD(0x4000103c, 0x7744e7f2); //开自动wrap
	_Sleep_(3);
}
FUNC void SSI3_standard_init()
{
	_WDWORD(0xC3000008, 0x00);//rSSI_SSIENR = 0x00;
	_WDWORD(0xC3000004, 0x00);  //rSSI_CTRLR1 = 0x00;
	_WDWORD(0xC3000000, 0x00000007);	 //rSSI_CTRLR0 = 0x07;
	_WDWORD(0xC3000014, 0x02);//rSSI_BAUDR = 0x8;
	_WDWORD(0xC3000018, 0x00);//rSSI_TXFTLR = 0x00;
	_WDWORD(0xC300001c, 0x00);//rSSI_RXFTLR = 0x00;
	_WDWORD(0xC30000f4, 0x8000);//rSSI_SPI_CTRLR0 = 0x8000;
	_WDWORD(0xC300002c, 0x00);	// rSSI_IMR = 0x00;	
	_WDWORD(0xC3000008, 0x01);//rSSI_SSIENR = 0x01;
}
FUNC void setupPeripherals(void)
{
	uint32_t app_start_addr;
	app_start_addr =&main;
	if((app_start_addr>0x10000000) &&(app_start_addr<0x12000000))
	{
		SSI1_standard_init();
	    Xip1_enable();
		
		
	}
	else if((app_start_addr>0x14000000) &&(app_start_addr<0x1c000000))
	{
		SSI3_standard_init();
	    Xip3_enable();

	}
	
	
}

setupPeripherals();
LOAD %L INCREMENTAL // 下载axf 文件到RAM
Setup();