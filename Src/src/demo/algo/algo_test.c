/**
 * @file algo_test.c
 * @author Product application department
 * @brief  ALGO  模块测试用例，仅供参考
 * @version  V1.0
 * @date 2025-02-11
 *
 * @copyright Copyright (c) 2025 China Core Co. Ltd. All Rights Reserved
 *
 */

/**
 * @defgroup Peripherals 外设模块
 * @{
 *
 * @defgroup ALGO ALGO模块
 * @ingroup Peripherals
 * @{
 */

// 头文件包含
#include "algo_test.h"


// 全局变量定义
#define RETERR()                                \
    do                                          \
    {                                           \
        printf("\t行号：%d ERR\r\n", __LINE__); \
        return;                                 \
    } while (0)
#define ALGO_AES_TEST 1
#define ALGO_SM4_TEST 0
#define ALGO_TRNG_TEST 0
#define ALGO_CRC_TEST 0
volatile dpa_level_t alg_dpa_level = dpa_disable;

static uint8_t buf2[] =
    {
        0x12, 0x00, 0x00, 0x00, 0x12, 0x15, 0x00, 0x00, 0x12, 0x15, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00,
        0x12, 0x15, 0x35, 0x24, 0x12, 0x15, 0x35, 0x24, 0xc0, 0x00, 0x00, 0x00, 0x12, 0x15, 0x35, 0x24,
        0xc0, 0x89, 0x00, 0x00};
// 函数定义

/**
 * @brief SM4 测试例程 
 *  
 */
void SM4_Demo(void)
{
    sm4_config_t sm4;

    uint8_t cipher[176] = {0};
    uint8_t Plain[176]={0};

    /*测试数据定义*/
    const uint8_t src[176]={0x57,0x41,0x4D,0x57,0x64,0x03,0xBE,0x26,0xAF,0x5F,0xDC,0x40,0x28,0x86,0xC0,0xBD,0xE9,0x50,0x25,0xF9,0xDB,0x2F,0xF1,0x63,0x20,0x50,0x65,0xB7,0x38,0xC0,0x1A,0x8D,
            0x4E,0x00,0x8D,0x4C,0x14,0xC7,0xFC,0xAE,0x25,0xD7,0xCE,0xF1,0x24,0x86,0x68,0xFB,0xDF,0x32,0xC6,0xEE,0x8D,0x7D,0x6E,0x82,0x7B,0x97,0x0E,0x33,0x90,0x4B,0x56,0xF6,
            0x89,0x95,0xEB,0x06,0x7E,0xE0,0x62,0x70,0xC6,0x16,0x26,0x0D,0x26,0x77,0x69,0x4E,0x88,0x06,0xE0,0x73,0xB4,0x79,0x06,0x08,0xD4,0x8D,0x71,0xB6,0x9D,0x48,0xE8,0x26,
            0x0D,0x68,0xC3,0x76,0xBD,0xE6,0xC9,0xFE,0xA1,0xED,0x12,0x70,0x0F,0x21,0xB0,0x68,0x68,0x91,0x5C,0xF4,0xD9,0x02,0x05,0xF0,0xA8,0x2B,0xED,0x42,0xE5,0x06,0x84,0xCA,
            0x2A,0xFE,0x44,0xCF,0xC2,0x94,0x53,0xA8,0xC1,0x0F,0xAE,0x75,0x52,0x2C,0xF4,0xBD,0x6A,0xFE,0x3A,0xA2,0x29,0x3B,0x91,0xD0,0xB0,0x9D,0xFB,0x07,0x1B,0xA5,0x8A,0xA2,
            0x2A,0x87,0xFA,0xBE,0x88,0x94,0xE0,0xA1,0x19,0xCC,0x05,0xBA,0x30,0x56,0xEC,0x52};

    const uint8_t key[16] = {0xB4,0x5D,0x01,0x7C,0xA7,0x56,0x6B,0xB4,0xF1,0xBA,0x0F,0xCE,0x96,0x07,0x99,0x3C};

    const uint8_t iv[16] = {0xD8,0x59,0xA1,0xCF,0x3F,0xD4,0x76,0xEC,0xD9,0x6F,0xDD,0x4C,0x2C,0x70,0x00,0x9F};

    const uint8_t cipher_ecb[176] = {
            0XCE,0x20,0xAB,0x0A,0xBD,0x83,0x46,0xBA,0x09,0xF4,0x68,0xC0,0xC3,0x27,0xE1,0xD4,0xA2,0xE0,0x2D,0x45,0x58,0xFC,0x5E,0xA2,0x5B,0xEB,0x22,0x9C,0xF8,0xC1,0x81,0x4F,
            0X20,0xA1,0xC6,0x7B,0x9D,0xB2,0xEA,0x6E,0x08,0x06,0xEA,0x6B,0x89,0xB0,0x99,0x36,0xB7,0xFD,0x78,0x94,0x39,0xA6,0xE5,0xAF,0x76,0x53,0x7A,0xC9,0x81,0x00,0x52,0x03,
            0XE5,0x20,0xE7,0x9D,0x3D,0x2A,0xB7,0xFF,0xD1,0xF5,0x6B,0xAD,0xF5,0x60,0x0F,0xEC,0x95,0xFB,0x92,0x06,0x98,0x2F,0xB1,0xF5,0x91,0x5E,0xC1,0x65,0x56,0xE9,0x7E,0x44,
            0X3F,0x73,0x4A,0xEB,0x6A,0xA6,0xFF,0x8D,0xE5,0xA7,0x43,0x10,0x20,0x75,0xF2,0x83,0x56,0xD5,0x1A,0x2B,0x31,0x50,0x0D,0x55,0x3D,0x05,0x89,0x55,0xCE,0xAA,0xE8,0x33,
            0X9C,0x49,0xF9,0x79,0xAC,0xF9,0xB5,0x30,0x49,0xA3,0x32,0xB2,0x6B,0x85,0x4E,0x01,0x9C,0x52,0x01,0x3B,0x2B,0xAA,0xDA,0xDD,0x83,0x00,0x3B,0x03,0xF7,0x3E,0x0B,0x5F,
            0XC8,0x79,0x2E,0xE3,0x95,0x70,0xB5,0x8C,0xA5,0x57,0x46,0x6E,0x88,0x81,0xBB,0xCE

    };
    const uint8_t cipher_cbc[176] = {
            0x9A,0x62,0xB3,0xA5,0x27,0x5D,0x7F,0x47,0xC5,0x84,0x74,0xE0,0x24,0xB7,0xBC,0x0C,0x72,0x94,0x28,0x12,0x57,0x33,0xF6,0x4F,0xFE,0x0C,0xB2,0x26,0xBB,0x11,0x91,0x6B,
            0x40,0x83,0xE0,0xAF,0xE1,0xFC,0x34,0x72,0x25,0x0A,0xD0,0xF6,0x6A,0x9A,0x5E,0xD9,0x51,0xF5,0x35,0x5C,0x25,0xE6,0x4C,0xC4,0xD1,0x87,0xAB,0x5F,0xCE,0x86,0x1B,0xFB,
            0xF3,0x74,0x1C,0x9B,0x98,0xE9,0x1D,0xB5,0x70,0xAD,0x80,0xBE,0x6F,0x41,0xA0,0x2A,0x05,0x7F,0x29,0x40,0x36,0xBF,0xBB,0x75,0xCE,0xD1,0x9E,0xFF,0xEC,0x14,0xCD,0x02,
            0x4D,0x85,0xB5,0xED,0xFD,0x66,0xA5,0x9B,0x6F,0xFF,0x99,0xA0,0x00,0x88,0x08,0x41,0xB7,0x4B,0x2F,0xFB,0x32,0x0E,0x22,0x63,0x38,0x15,0xF1,0x43,0xB1,0x06,0xB4,0x7C,
            0xDD,0x28,0x5D,0xDA,0x67,0xA2,0x77,0x40,0xC4,0x91,0x90,0xB7,0x65,0x72,0xA4,0xEE,0x44,0xD8,0x03,0xFF,0xC3,0x2C,0x9D,0x7A,0x5C,0x60,0xAD,0x23,0x00,0xD1,0x8D,0xC0,
            0x65,0xD9,0x93,0x2F,0x92,0x2A,0x7E,0x7D,0x66,0x3C,0x0E,0xF0,0x58,0xDD,0xAD,0xFB};
    printf("\t函数名：%s \r\n",__FUNCTION__);

    sm4.level = alg_dpa_level;
    sm4.mode =  ALG_ENCRYPT;
    sm4.type = ALG_ECB;
    sm4.cofbits = ALG_COFBIT_DUMMY;

    printf("\t\tSM4 ECB 加密模式测试:");
    if(hal_sm4_cryptographic(&sm4, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, sizeof(src)))
    {
        printf("测试失败 \r\n");
        while(1);
    }

    if(memcmp((uint8_t *)cipher_ecb,cipher,176) != 0)
    {
        printf("数据比对失败 \r\n");
        while(1);
    }

    printf("\t通过\r\n");

    printf("\t\tSM4 ECB 解密模式测试:");

    sm4.mode =  ALG_DECRYPT;
    if(hal_sm4_cryptographic(&sm4, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_ecb, Plain, sizeof(src)))
    {
        printf("测试失败 \r\n");
        while(1);
    }

    if(memcmp((uint8_t *)src,Plain,176) != 0)
    {
        printf("数据比对失败 \r\n");
        while(1);
    }

    printf("\t通过\r\n");


    printf("\t\tSM4 CBC 加密模式测试:");

    sm4.mode =  ALG_ENCRYPT;
    sm4.type = ALG_CBC;
    if(hal_sm4_cryptographic(&sm4, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, sizeof(src)))
    {
        printf("测试失败 \r\n");
        while(1);
    }

    if(memcmp((uint8_t *)cipher_cbc, cipher, 176) != 0)
    {
        printf("数据比对失败 \r\n");
        while(1);
    }

    printf("\t通过\r\n");
    printf("\t\tSM4 CBC 解密模式测试:");

    sm4.mode =  ALG_DECRYPT;
    if(hal_sm4_cryptographic(&sm4, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_cbc, Plain, sizeof(src)))
    {
        printf("测试失败 \r\n");
        while(1);
    }

    if(memcmp((uint8_t *)src, Plain, 176) != 0)
    {
        printf("数据比对失败 \r\n");
        while(1);
    }

    printf("\t通过\r\n");
}

/**
 * @brief AES 测试例程
 * 
 */
void AES_Demo(void)
{
    aes_config_t aes;

    const uint8_t key[32] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00};
    const uint8_t iv[16] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};

    const uint8_t src[32] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
    ;

    const uint8_t cipher_aes128_ecb[32] = {0xA5, 0xD2, 0xAB, 0x70, 0x45, 0xD0, 0x96, 0xA4, 0xC2, 0xF1, 0xE3, 0xFA, 0x0C, 0x0C, 0xC3, 0x2C, 0xA5, 0xD2, 0xAB, 0x70, 0x45, 0xD0, 0x96, 0xA4, 0xC2, 0xF1, 0xE3, 0xFA, 0x0C, 0x0C, 0xC3, 0x2C};
    const uint8_t cipher_aes192_ecb[32] = {0x23, 0xB1, 0x26, 0x2D, 0xE8, 0xD6, 0xA5, 0x73, 0xB7, 0x89, 0x32, 0xDD, 0x15, 0x71, 0x70, 0xA4, 0x23, 0xB1, 0x26, 0x2D, 0xE8, 0xD6, 0xA5, 0x73, 0xB7, 0x89, 0x32, 0xDD, 0x15, 0x71, 0x70, 0xA4};
    const uint8_t cipher_aes256_ecb[32] = {0xAD, 0xA6, 0xDB, 0xCD, 0x7B, 0xA9, 0xC6, 0xDA, 0x07, 0x50, 0x04, 0x2C, 0x56, 0x03, 0xAE, 0x47, 0xAD, 0xA6, 0xDB, 0xCD, 0x7B, 0xA9, 0xC6, 0xDA, 0x07, 0x50, 0x04, 0x2C, 0x56, 0x03, 0xAE, 0x47};

    const uint8_t cipher_aes128_cbc[32] = {0x77, 0xDF, 0xA7, 0x24, 0x98, 0x3C, 0x2C, 0x4C, 0x38, 0xC2, 0x95, 0x86, 0xFF, 0xD6, 0x2F, 0x94, 0x2A, 0x2A, 0x6D, 0x00, 0x04, 0x33, 0x64, 0x40, 0x73, 0x36, 0xC5, 0x76, 0x42, 0xD0, 0x4E, 0x2D};
    const uint8_t cipher_aes192_cbc[32] = {0xB9, 0xD1, 0x5B, 0x06, 0x1C, 0x5A, 0xC9, 0x88, 0x46, 0x2A, 0x73, 0x2D, 0xA8, 0xDA, 0x10, 0x40, 0x3B, 0xB5, 0xA6, 0x48, 0xC9, 0xC4, 0xE5, 0x82, 0x3E, 0xDF, 0x20, 0xF0, 0x13, 0xD4, 0x18, 0x23};
    const uint8_t cipher_aes256_cbc[32] = {0x43, 0xD5, 0x99, 0xD1, 0x7E, 0x6F, 0x93, 0x12, 0xEA, 0x59, 0xAB, 0x19, 0xE1, 0xEF, 0x75, 0x00, 0x39, 0x0E, 0x96, 0xE1, 0xB9, 0xEC, 0x64, 0x57, 0x5C, 0x41, 0xBC, 0x36, 0xD7, 0x1F, 0x82, 0x94};

    uint8_t cipher[32];
    uint8_t plain[32];
    printf("\t函数名：%s \r\n", __FUNCTION__);

    aes.level = alg_dpa_level;

    aes.mode = ALG_ENCRYPT;

    aes.type = ALG_ECB;

    aes.KBits = ALG_KEY128;

    aes.cofbits = ALG_COFBIT_DUMMY;

    printf("\t\tAES-128 ECB 加密模式测试:");

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)cipher_aes128_ecb, cipher, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-128 ECB 解密模式测试:");

    aes.mode = ALG_DECRYPT;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_aes128_ecb, plain, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)src, plain, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-128 CBC 加密模式测试:");

    aes.mode = ALG_ENCRYPT;

    aes.type = ALG_CBC;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)cipher_aes128_cbc, cipher, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-128 CBC 解密模式测试:");

    aes.mode = ALG_DECRYPT;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_aes128_cbc, plain, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)src, plain, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-192 ECB 加密模式测试:");

    aes.mode = ALG_ENCRYPT;

    aes.type = ALG_ECB;

    aes.KBits = ALG_KEY192;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)cipher_aes192_ecb, cipher, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-192 ECB 解密模式测试:");

    aes.mode = ALG_DECRYPT;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_aes192_ecb, plain, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)src, plain, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-192 CBC 加密模式测试:");

    aes.mode = ALG_ENCRYPT;

    aes.type = ALG_CBC;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)cipher_aes192_cbc, cipher, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-192 CBC 解密模式测试:");

    aes.mode = ALG_DECRYPT;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_aes192_cbc, plain, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)src, plain, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-256 ECB 加密模式测试:");

    aes.mode = ALG_ENCRYPT;

    aes.type = ALG_ECB;

    aes.KBits = ALG_KEY256;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)cipher_aes256_ecb, cipher, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-256 ECB 解密模式测试:");

    aes.mode = ALG_DECRYPT;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_aes256_ecb, plain, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)src, plain, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-256 CBC 加密模式测试:");

    aes.mode = ALG_ENCRYPT;

    aes.type = ALG_CBC;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)src, cipher, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)cipher_aes256_cbc, cipher, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");

    printf("\t\tAES-256 CBC 解密模式测试:");

    aes.mode = ALG_DECRYPT;

    if (hal_aes_cryptographic(&aes, (uint8_t *)key, (uint8_t *)iv, (uint8_t *)cipher_aes256_cbc, plain, 32))
    {
        RETERR();
    }

    if (memcmp((uint8_t *)src, plain, 32) != 0)
    {
        RETERR();
    }

    printf("\t通过\r\n");
    printf("\t\t=========================================\r\n");
}

/**
 * @brief 随机数测试例程
 * 
 */
void TRNG_Demo(void)
{
    uint32_t random;
    uint32_t tmp[100];

    uint32_t i = 0;

    trng_handle_t htrng;

    htrng.instance = TRNG;

    htrng.dividor = 59;

    printf("函数名：%s \r\n", __FUNCTION__);

    hal_trng_init(&htrng);
    for (i = 0; i < 100; i++)
    {
        tmp[i] = hal_trng_getrandom(&htrng);
        // printf(".。。。。。。。。。");
    }
    for (i = 0; i < 100; i++)
    {
        printf("%08x\r\n", tmp[i]);
    }
    while (i < 1000)
    {
        if ((i & 0x07) == 0)
        {
            printf("\r\n");
        }

        random = hal_trng_getrandom(&htrng);

        printf("%08x \t", random);
        i++;
    }
}

/**
 * @brief CRC 测试例程 
 * 
 */
void Crc_Demo(void)
{
    uint8_t crc_8 = 0;
    uint16_t crc_16 = 0;
    uint32_t crc_32 = 0;
    crc_init_t CRC_InitStruct;

    CRC_InitStruct.CRC_DataFormat = CRC_DATA_FORMAT_BIGENDDING;
    CRC_InitStruct.CRC_Mode = CRC_MODE_CRC_8;
    CRC_InitStruct.CRC_SourceSel = CRC_SOURCE_SEL_FROM_CPU;
    hal_crc_config(CRC1, &CRC_InitStruct);
    hal_crc_setinitvalue(CRC1, 0xffffffff);

    crc_8 = hal_crc_calccrc8(CRC1, buf2, sizeof(buf2) / sizeof(char));

    printf("CRC result is 0x%02x\r\n", crc_8);

    CRC_InitStruct.CRC_DataFormat = CRC_DATA_FORMAT_BIGENDDING;
    CRC_InitStruct.CRC_Mode = CRC_MODE_CRC_16;
    CRC_InitStruct.CRC_SourceSel = CRC_SOURCE_SEL_FROM_CPU;

    hal_crc_config(CRC1, &CRC_InitStruct);
    hal_crc_setinitvalue(CRC1, 0xffffffff);

    crc_16 = hal_crc_calccrc16(CRC1, buf2, sizeof(buf2) / sizeof(char));

    printf("CRC result is 0x%04x\r\n", crc_16);

    CRC_InitStruct.CRC_DataFormat = CRC_DATA_FORMAT_LITTLEENDDING;
    CRC_InitStruct.CRC_Mode = CRC_MODE_CRC_32;
    CRC_InitStruct.CRC_SourceSel = CRC_SOURCE_SEL_FROM_CPU;

    hal_crc_config(CRC1, &CRC_InitStruct);
    hal_crc_setinitvalue(CRC1, 0xffffffff);
    crc_32 = hal_crc_calccrc32(CRC1, buf2, sizeof(buf2) / sizeof(char));
    printf("\r\nCRC little endding result is 0x%08x\r\n", crc_32);

    CRC_InitStruct.CRC_DataFormat = CRC_DATA_FORMAT_BIGENDDING;
    CRC_InitStruct.CRC_Mode = CRC_MODE_CRC_32;
    CRC_InitStruct.CRC_SourceSel = CRC_SOURCE_SEL_FROM_CPU;

    hal_crc_config(CRC1, &CRC_InitStruct);
    hal_crc_setinitvalue(CRC1, 0xffffffff);
    crc_32 = hal_crc_calccrc32(CRC1, buf2, sizeof(buf2) / sizeof(char));
    printf("\r\nCRC big endding result is 0x%08x\r\n", crc_32);
}
/**
 * @brief  ALGO 模块测试示例函数
 *
 */
void algo_demo(void)
{
#if ALGO_AES_TEST
    printf("\t|-AES测试:AES_Demo\r\n");
    AES_Demo();

#elif ALGO_SM4_TEST
    printf("\t|-SM4测试:SM4_Demo\r\n");
    SM4_Demo();

#elif ALGO_TRNG_TEST
    printf("\t|-trng测试:trng_Demo\r\n");
    TRNG_Demo();

#elif ALGO_CRC_TEST
    printf("\t|-crc测试:crc_Demo\r\n");
    Crc_Demo();

#endif
}

/** @} */  // 结束 ALGO 模块分组
/** @} */  // 结束外设模块分组
